### 1.1 Python 冒泡排序算法
#### 1.1.1 概述

冒泡排序算法是最简单的排序算法，如果顺序错误，可以反复交换相邻的元素来实现排序。
#### 1.1.2 算法描述
```text
//冒泡排序1
void BubbleSort1(int a[], int n)
{
    int i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n - i - 1; j++)
            if (a[j] > a[j + 1])
                Swap(a[ j ], a[j + 1]);
}
```
#### 1.1.3 语言描述
冒泡排序原理: 每一趟只能将一个数归位， 如果有 n 个数进行排序，只需将 n-1 个数归位， 也就是说要进行 n-1 趟操作(已经归位的数
不用再比较)。冒泡排序虽然解决了桶排序浪费空间的问题， 但是冒泡排序的效率特别低。

**算法步骤**

+ 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
+ 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
+ 针对所有的元素重复以上的步骤，除了最后一个。
+ 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

#### 1.1.4 Example

##### 冒泡排序动态图示

![bubble_sort](../images/Bubble-sort-example-300px.gif)

##### 一次正常的冒泡算法描述如如下：

第一遍：

（**5** **1** 4 2 8） - >（**1** **5** 4 2 8），这里，算法比较前两个元素，交换自5> 1

（1 **5** **4** 2 8） - >（1 **4** **5** 2 8），交换自5> 4 

（1 4 **5** **2** 8） - >（1 4 **2** **5** 8），交换自5> 2 

（1 4 2 **5** **8**） - >（1 4 2 **5** **8**），现在，由于这些元素已经按顺序排列（8> 5），算法不会交换它们。

第二次通过：

（**1** **4** 2 5 8） - >（**1** **4** 2 5 8）

（1 **4** **2** 5 8） - >（1 **2** **4** 5 8），交换4> 2 

（1 2 **4** **5** 8） - > （1 2 **4** **5** 8）

（1 2 4 **5** **8**） - >（1 2 4 **5** **8**）

现在，数组已经排序，但算法不知道它是否已排序完全。

第三次通过：

（**1** **2** 4 5 8） - >（**1** **2** 4 5 8）

（1 **2** **4** 5 8） - >（1 **2** **4** 5 8）

（1 2 **4** **5** 8） - >（1 2 **4** **5** 8 ）

（1 2 4 **5** **8**） - >（1 2 4 **5** **8**）


##### 考虑递归实现
使用递归冒泡排序并没有性能/实现上的优势，但有助于理解冒泡排序以及递归思想。因为将循环化为递归，避免不了“方法压栈”的现象出现。

现在来考虑冒泡排序算法，根据以上的例子部分，在第一遍中，算法将最大的元素移动到数组最后的位置（按递增顺序），在第二遍中，算法将第二大的元素放置在倒数第二的位置，依次类推。

**一种递归思想：**

    1.基本情况：数组大小为 1，返回
    2.做一次正常的冒泡排序。此过程调用递归算法
    3.递归子数组


#### 1.1.5 算法实现

Python实现
```
#!/usr/bin/env python
# Python 程序完成冒泡排序


# 一般冒泡
def basic_bubble(arr):
    n = len(arr)
    if n <= 1:
        return

    for i in range(n):  # 遍历所有数组元素
        # 已经到了最后一个元素位置
        for j in range(0, n-i-1):
            # 从[0,n-i-1]遍历数组
            # 如果找到的元素更大，则交换
            # 继续比较下一个元素
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr


# 递归实现冒泡排序
def recursive_bubble(arr):
    for i, num in enumerate(arr):
        try:
            if arr[i+1] < num:
                arr[i] = arr[i+1]
                arr[i+1] = num
                recursive_bubble(arr)
        except IndexError:
            pass
    return arr

```

c++ 实现
```
void bubble_sort(int *a, int len){
	for(int i=0; i<len;i++){
	    for(int j=0; j<len-i-1;j++){
		    if(a[j] > a[j+1]){
			    swap(a[j], a[j+1]);
			}
		}
	}
}
```

【相关推荐】
+ [5.7. The Bubble Sort¶](http://interactivepython.org/runestone/static/pythonds/SortSearch/TheBubbleSort.html)